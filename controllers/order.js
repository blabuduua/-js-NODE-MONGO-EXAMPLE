const Order = require('../models/Order');
const errorHandler = require('../utils/errorsHandler');


module.exports.getAll = async function (req, res) {

    // ДЛЯ ХРАНЕНИЯ ЗАПРОСА К БД
    const query = {
        // ДЛЯ СБОРА ВСЕХ ЗАКАЗОВ КОТОРІЕ СОЗДАЛ ЮЗЕР ЗАПРАШИВАЮЩИЙ ЄТОТ РОУТ
        user: req.user.id,
    }

    // ДЛЯ ГЕНЕРАЦИИ ЗАПРОСА НА ХОДУ В ЗАВИСИМОСТИ ОТ ПАРАМЕТРОВ ЗАПРОСА

    // ДЛЯ ПОИСКА ДАТІ СТАРТА В ЗАПРОСЕ, ЧТО БУДЕТ ОЗНАЧАТЬ НАЧАЛЬНУЮ ДАТУ СОЗДАНИЯ ЗАПИСИ,
    // НАЧИНАЯ С КОТОРОЙ НУЖНО ВЕРНУТЬ ЗАПИСИ
    if(req.query.start){
        // ДЛЯ ЗАПИСИ В ДИНАМИЧЕСКИ ФОРМИРУЮЩЕЮСЯ ЗАПРОС
        query.date = {
            // ДЛЯ ИСПОЛЬЗОВАНИЯ ФИЛЬТРА МОНГУС $gte grater/equal БОЛЬШЕ ИЛИ РАВНО
            $gte: req.query.start
        }
    }

    // ДЛЯ ПОИСКА ДАТІ КОНЦА В ЗАПРОСЕ, ЧТО БУДЕТ ОЗНАЧАТЬ КОНЕЧНУЮ ДАТУ СОЗДАНИЯ ЗАПИСИ,
    // ЗАКАНЧИВАЯ КОТОРОЙ НУЖНО ВЕРНУТЬ ЗАПИСИ
    if(req.query.end){
// ДЛЯ ПРОВЕРКИ ОТРАБОТАЛА ЛИ ПРЕДІДУЩАЯ ПРОВЕРКА И СФОРМИРОВАН ЛИ ОБЬЕКТ query.date ДЛЯ ЗАПРОСА
        if(!query.date){
            // ДЛЯ СОЗДАНИЯ ПУСТОГО ОБЬЕКТА ДАТЫ
            query.date = {}
        }

// ДЛЯ ОБРАЩЕНИЯ К ОБЬЕКТУ ДАТЫ МОГУС ПРЕДСОЗДАЛ СВОЙСТВА ОБЬЕКТА К КОТОРЫМ МВ МОЖЕМ ОБРАТИТСЯ

        // ДЛЯ ОБРАЩЕНИЯ К СВОЙСТВУ ФИЛЬТРА МОГУС $lte lower/equal МЕНЬШЕ ИЛИ РАВНО
        query.date['$lte'] = req.query.end

        // ДЛЯ ЗАПИСИ В ДИНАМИЧЕСКИ ФОРМИРУЮЩЕЮСЯ ЗАПРОС
        query.date = {
            // ДЛЯ ИСПОЛЬЗОВАНИЯ ФИЛЬТРА МОНГУС $gte grater/equal БОЛЬШЕ ИЛИ РАВНО
            $gte: req.query.end
        }
    }

    // ДЛЯ ПРОВЕРКИ ОТПРАВЕЛ ЛИ КОНКРЕТНЫЙ НОМЕР ЗАКАЗА ДЛЯ ОТОБРАЖЕНИЯ
    if(req.query.order){
        // ДЛЯ ДОБАВЛЕНИЕ В КОНСТРУКТОР ЗАПРОСА КЛЮЧА ФОЛЬТРА С НОМЕРОМ ЗАКАЗ
        query.order = +req.query.order
    }

    try {
        // ДЛЯ СБОРА ВСЕХ ЗАКАЗОВ
        const orders = await Order

            // ИЩЕМ В ДОКУМЕНТІ ПОДХОДЯЩИЕ ПОД ЗАПРОС
            .find(query)

            // ДЛЯ СОРТИРОВКИ ПО ДАТЕ СОЗДАНИЯ ОТ САМІХ ПОСЛЕДНИХ ДО СТАРІХ
            .sort({
                date: -1
            })

            // ДЛЯ ПАГИНАЦИИ ЗАБИРАЕМ СО СТРОКИ ГЕТ ЗАПРОСА СТРАНИЦУ НА КОТОРОЙ НАХОДИМСЯ
            // ДЛЯ ИЗМЕНЕНИЯ ТИПА ДАННІХ СО СТРОКИ В ЦИФРУ СТАВИМ +
            .skip(+req.query.offset)

            // ДЛЯ ПАГИНАЦИИ ЗАБИРАЕМ УСТАНОВЛЕННІЙ ЛИМИТ ЗАПИСЕЙ ДЛЯ ВОЗВРАТА
            .limit(+req.query.limit)

        // ДЛЯ ВОРМИРОВАНИЯ И ОТПРАВКИ ОТВЕТА C РЕЗУЛЬТАТОМ СБОРА ВСЕХ ЗАКАЗОВ
        res.status('200').json(orders)

    }catch (e) {
        errorHandler(res, e);
    }
};

module.exports.createOne = async function (req, res) {

    // ДЛЯ ОПРЕДЕЛЕНИЯ ПОСЛЕДНЕЙ ЗАПИСИ В БД ПО ДАТЕ СОЗДАНИЯ
    // ДЛЯ ПОЛЕЧЕНИЯ ВСЕХ ЗАКАЗОВ ПОЛЬЗОВАТЕЛЯ ДОЖИДАЕМСЯ ПОЛЧЕНИЯ ДАННІХ ОТ МОДЕЛИ
    const lastOrder = await Order
        .findOne({user: req.user.id})
        .sort({
            // ДЛЯ СОРТИРОВКИ ПО ПОЛЮ ДАТІ ПО УБІВАНИЮ (Т.Е. САМІЙ ПОСЛЕДНИЙ ЕЛЕМЕНТ)
            date: -1
        })

    // ДЛЯ ПРОВЕРКИ ЕСТЬ ЛИ В БД ХОТЬ ОДНА ЗАПИСЬ С ЗАКАЗОМ
    // ЕСЛИ ЕСТЬ, ЗНАЧИТ ЄТО ПОСЛЕДНИЙ - ПРИСВАИВАЕМ МАКСИМАЛЬНОМУ ЗНАЧЕНИЮ ЕГО АЙДИ
    // ДАЛЕЕ ПРИ СОХРАНЕНИИ МІ УВЕЛИЧИМ ЕГО НА 1
    // ЕСЛИ НЕТ, ЗНАЧИТ ЄТО ПЕРВАЯ ЗАПИСЬ - УКАЗІВАЕМ ПЕРВІЙ НОМЕР 0
    // ДАЛЕЕ ПРИ СОХРАНЕНИИ МІ УВЕЛИЧИМ ЕГО НА 1
    const maxOrder = lastOrder ? lastOrder.order : 0

    try {
        // ДЛЯ СОЗДАНИЯ НОВОГО ОБЬЕКТА МОДЕЛИ И ПЕРЕДАЧИ ЕЙ ВСЕХ ЗАТРЕБОВАННЫХ ПОЛЕЙ
        // ДЛЯ ДОЖИДАНИЯ СОХРАНЕНИЯ В БД В АСИНХРОННОМ РЕЖИМЕ (ASYNC) ИСПОЛЬЗУЕМ AWAIT
        const order = await new Order({

            // ДЛЯ ЗАПОЛНЕНИЯ ДАННЫМИ ИЗ HTML ФОРМЫ ИЗ ЗАПРОСА
            list: req.body.list,

            // ДЛЯ ЗАПОЛНЕНИЯ АВТОРА ЭКЗЕМПЛЯРОМ АВТОРИЗИРОВАННОГО ЮЗЕРА
            user: req.user.id,

            // ДЛЯ УКАЗАНИЯ НОМЕРА ТЕКУЩЕГО ЗАКАЗА (АВТОМАТИЧЕСКОГО АВТОИНКРЕМЕНТА НЕТ)
            order: maxOrder + 1,

            // ДЛЯ СОХРАНЕНИЯ ЕКЗЕМПЛЯРА МОДЕЛИ
        }).save();

        //ДЛЯ ВЫДАЧИ ОТВЕТА ПОСЛЕ СОХРАНЕНИЯ,
        // ДЛЯ ДАЛЬНЕЙШЕГО ИСПОЛЬЗОВАНИЯ ОТДАЁМ СОЗДАННЫЙ ОБЬЕКТ ORDER
        res.status('201').json(order)
    }catch (e) {
        errorHandler(res, e);
    }
};